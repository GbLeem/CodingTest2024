가로 m 세로 n일때

int nx = cur.first  +dx[dir]; //행
int ny = cur.second + dy[dir]; //열

if(nx < 0 || nx >= n || ny < 0 || ny >=m)
	continue;



===========================
1. 그림의 갯수랑 크기 물어보는 문제
-> 이중  for문을 써서 시작할 수 있는 점 찾아서 시작하는 기법

2. 거리를 물어보는 문제
-> 시작점을 주니까 시작점을 Q에 넣고 방문할때마다 거리 하나씩 늘려주기
bfs끝나면 도착지점의 거리 나옴

3. 시작점이 여러개
-> 한번에 여러곳에서 bfs가 돌아가야할 때 시작점을 모두 넣고 시작함
이때 다른 처리 안해도 알아서 잘 동시에 돌아감
거리는 항상 -1로 초기화 해주기 

4. 시작점이 여러개(두개)인데, 하나의 시작점이 다른 시작점에 영향을 미칠때
단 다른 시작점은 해당 시작점에 영향을 미치지 않을 때
-> Q두개 만들고 dist(vis) 도 두개 만들어서 두번 돌린다.
추가로 한 시작점이 다른 시작점에 영향을 미치는 것에 대한 처리를 해주면 된다.

cf)각자의 시작점이 영향을 미치면 그건 백트래킹까지 써야한다

5. 이차원 배열에서 점프하는 느낌(가장 빠른 시간 찾기)
-> 그냥 일차원 배열 선언해서 range based for 문 써서 찾기
근데 범위를 항상 주의하자